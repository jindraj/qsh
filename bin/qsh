#!/bin/bash

QSH_BASE=~/.qsh
QSH_CLIENTS=$QSH_BASE/clients
QSH_CONNECTIONS=$QSH_BASE/connections

# Check that we are in a tmux session
if [[ -z "${TMUX}" ]]; then
  echo "You must use qsh from within a tmux session";
  exit -1;
fi;

function usage {
  local has_tree=0;
  which tree > /dev/null 2>&1;
  if [[ $? == 0 ]]; then
    has_tree=1;
  fi;

  echo "usage: qsh <connection> | <invocation> ...";
  echo "       qsh -t <type> <invocation> ..."
  echo "       qsh -c <command> <connection> ..."
  echo;
  echo "Connections can be registered using qsh-reg, otherwise just invoke your";
  echo "sql client to connect to a data source. In both cases, additional";
  echo "command-line arguments can be provided."
  echo;
  echo "When using qsh with a generic tool, use -t to specify the type of file to";
  echo "open by default in the editor. This can be useful for accessing features,";
  echo "such as completion. Using this option implicitly sets the pager to cat if";
  echo "a \$QSH_PAGER has not been set, which can sometimes provide better text";
  echo "rendering for REPLs.";
  echo;
  echo "Use -c to provide a command, such as pg_dump or mysqldump, so that it can";
  echo "make use of a registered connection, providing additional arguments as";
  echo "required.";

  if [[ $has_tree -eq 1 ]]; then
    echo;
    tree --prune --noreport "$QSH_CONNECTIONS";
  fi;
  exit 0;
}

while getopts "t:c:" arg; do
  case $arg in
    c)
      CLIENT_COMMAND=$OPTARG
      ;;
    t)
      FILE_TYPE=$OPTARG
      if [[ "$FILE_TYPE" != "sql" ]]; then
        REPL_MODE=1
      fi;
      ;;
  esac
done

# Move past the options
shift $(expr $OPTIND - 1);

function client_connect {
  local CLIENT=$1

  CLIENT_NAME=$(basename "$CLIENT");
  if [[ ! -d "$QSH_CLIENTS/$CLIENT_NAME" ]]; then
    CLIENT_NAME=generic
  fi;

  CLIENT_CONNECT="$QSH_CLIENTS/$CLIENT_NAME/qsh-connect";
  if [[ ! -f "$CLIENT_CONNECT" ]]; then
    CLIENT_CONNECT="$QSH_CLIENTS/generic/qsh-connect";
  fi;

  echo "$CLIENT_CONNECT";
}

CONNECTION=$1
shift 1;
if [[ -z "$CONNECTION" ]]; then
  usage;
fi;

CONNECTION_JSON=$CONNECTION;
if [[ "$CONNECTION_JSON" != *.json ]]; then
  CONNECTION_JSON="${CONNECTION}.json";
fi;

CONNECTION_FILE=$QSH_CONNECTIONS/$CONNECTION_JSON
CLIENT_CONNECTION_FILE=$QSH_CONNECTIONS/.$(basename "$CONNECTION_FILE").reg
if [[ ! -f "$CONNECTION_FILE" ]]; then
  # Try to perform a direct invocation
  CLIENT=$CONNECTION
  INVOCATION="$*"
  PASSWORD=null
  PROMPT=true

  # Invoke the client
  source "$(client_connect "$CLIENT")";
  exit;
fi;

CONNECTION_DATA=$(cat "$CONNECTION_FILE");

CLIENT="$(echo "$CONNECTION_DATA" | jq -r '.client')";
INVOCATION="$(echo "$CONNECTION_DATA" | jq -r '.invocation')";
PROMPT="$(echo "$CONNECTION_DATA" | jq -r '.prompt')";
USING_PASSWORD="$(echo "$CONNECTION_DATA" | jq -r '.using_password')";
PROMPT="$(echo "$CONNECTION_DATA" | jq -r '.prompt')";
VANILLA="$(echo "$CONNECTION_DATA" | jq -r '.vanilla')";

FILE_TYPE="$(echo "$CONNECTION_DATA" | jq -r '.type')";
if [[ "$FILE_TYPE" != "sql" ]]; then
  REPL_MODE=1
fi;

if [[ ! -z "$CLIENT_COMMAND" ]]; then
  CLIENT=$CLIENT_COMMAND
  VANILLA=true
fi;

if [ "$CLIENT" == "null" ] || [ "$INVOCATION" == "null" ]; then
  echo "invalid connection definition";
  exit -1;
fi;

INVOCATION="$INVOCATION $*";

# Setup environment, if necessary
QSH_ENV="$(echo "$CONNECTION_DATA" | jq '.env')";
QSH_ENV_KEYS="$(echo "$QSH_ENV" | jq 'keys')";

ENV_INDEX=0
while [[ $ENV_INDEX -ne -1 ]];
do
  ENV_VARIABLE="$(echo "$QSH_ENV_KEYS" | jq -r ".[$ENV_INDEX]")";
  if [[ "$ENV_VARIABLE" != "null" ]]; then
    ENV_VALUE="$(echo "$QSH_ENV" | jq -r ".$ENV_VARIABLE")";
    export $ENV_VARIABLE=$ENV_VALUE;

    ENV_INDEX=$((ENV_INDEX + 1));
  else
    ENV_INDEX=-1;
  fi;
done;

source "$(client_connect "$CLIENT")";

